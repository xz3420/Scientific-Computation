"""
Code for Scientific Computation Project 3
Please add college id here
CID: 01872353
"""
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
#use scipy as needed
#----------------------
# Code for part 1
#----------------------

def ufield(r,th,u,levels=50):
    """Displays velocity field stored in 2D array, u, at
    one instant in time. Uses polar grid data stored in 1D arrays r and th.
    Use/modify/ignore as needed.
    """
    Nth = th.size
    Nr = r.size
    thn = np.zeros(Nth+1)
    thn[:-1]=th;thn[-1]=th[0]
    un = np.zeros((Nr,Nth+1))
    un[:,:-1] = u;un[:,-1]=un[:,0]
    thg,rg = np.meshgrid(thn,r)
    xg = rg*np.cos(thg)
    yg = rg*np.sin(thg)
    plt.figure()
    plt.contourf(xg,yg,un,levels)
    plt.axis('equal')
    return None

def part1q1():
    """
    Question 1.1
    generate graphs for analysis
    """

    #-------------------------
    #Load data
    #t: times
    #r: radial positions
    #th: angular positions
    #U: velocity field, u(r,th,t)
    temp = np.load('data1.npz')
    t = temp['t'];r = temp['r'];th = temp['theta'];U = temp['U']
    temp = None
    #-------------------------

    #Add code here
    U1 = U[np.where(r==0.1)][0]    # r = 0.1
    U2 = U[np.where(r==0.5)][0]    # r = 0.5
    
    # figure 1
    fig,ax = plt.subplots(nrows=1, ncols=2, figsize=(13,5))
    
    ax[0].set_title("The velocity field at r=0.1",fontsize=15)
    ax[0].set_xlabel("Time",fontsize=12)
    ax[0].set_ylabel(r'$\theta$',fontsize=12)
    im = ax[0].contourf(t,th,U1,50,cmap='summer')
    
    ax[1].set_title("The velocity field at r=0.5",fontsize=15)
    ax[1].set_xlabel("Time",fontsize=12)
    ax[1].set_ylabel(r'$\theta$',fontsize=12)
    ax[1].contourf(t,th,U2,50,cmap='summer')
    
    cbar_ax = fig.add_axes([0.96, 0.2, 0.025, 0.6])
    fig.colorbar(im, cax=cbar_ax)

    # figure 2
    fig,ax = plt.subplots(nrows=2, ncols=1, figsize=(13,7))
    for i in range(len(th)-1):
        ax[0].plot(t,U1[i])
        ax[0].plot(t,U2[i])
    ax[0].plot(t,U1[len(th)-1], label='r = 0.1 (upper)')  # to set legend
    ax[0].plot(t,U2[len(th)-1], label='r = 0.5 (lower)')
    ax[0].set_xlabel('Time',fontsize=12)
    ax[0].set_ylabel('velocity',fontsize=12)
    ax[0].legend()
    
    fig.subplots_adjust(hspace=0.3)
    
    for j in range(len(t)):
        ax[1].plot(th,U1[:,0])
        ax[1].plot(th,U2[:,0])
    ax[1].plot(th,U1[:,len(t)-1], label='r = 0.1 (upper)')  # to set legend
    ax[1].plot(th,U2[:,len(t)-1], label='r = 0.5 (lower)')
    ax[1].set_xlabel(r'$\theta$',fontsize=12)
    ax[1].set_ylabel('velocity',fontsize=12)
    ax[1].legend()
    
    return None #modify as needed

def part1q2C(U,tol=1e-10):
    """
    Question 1.2: Construct one or more arrays from U
    that can be used by part1q2E
    Input:
        U: 3-D data array
        inputs: can be used to provide other input as needed
    Output:
        arrays: a tuple containing the arrays produced from U
    """
    #load data
    temp = np.load('data1.npz')
    t = temp['t'];r = temp['r'];th = temp['theta'];U = temp['U']
    temp = None

    #Add code here
    m,n,l = np.shape(U)
    a = m*n         # new dimension of U2d
    U2d = U.reshape(-1,l)
    mean = U2d.mean(axis=1)
    Uc = np.transpose(U2d.T-mean)       # remove the mean of each row 
    
    # use the first k component to project
    u, s, wT = np.linalg.svd(Uc)
    ns = np.sum(1/(a-1)*s**2 > tol)    # number of big principle components
    Utilda = np.dot(u[:,:ns].T,Uc)
    # [projected U, eigenvectors, mean for each row, shape of original matrix]
    arrays = [Utilda, u[:,:ns], mean, (m,n,l)]
    
    return arrays
    

def part1q2E(arrays,inputs=()):
    """
    Question 1.2: Generate numpy array with same shape as U (see part1q2E above)
    that has some meaningful correspondence to U
    Input:
        arrays: tuple generated by part1q2C
        inputs: can be used to provide other input as needed
    Output:
        Unew: a numpy array with the same shape as U
    """

    #Add code here
    # reconstruct the data use PCA
    reconstruct = arrays[1] @ arrays[0] + arrays[2][:,np.newaxis]      # np.newaxis for broadcasting
    Unew = reconstruct.reshape(arrays[3])  
 
    return Unew

def part1q3():
    """
    Question 1.3
    Add input/output as needed
    """

    #-------------------------
    #Load data
    #U: matrix with missing data
    #R1,R2,R3: three "repaired" matrices
    temp = np.load('data2.npz')
    U = temp['U'];R1 = temp['R1'];R2=temp['R2'];R3=temp['R3']
    temp = None
    #-------------------------

    #Add code here
    print('Rank of U is',np.linalg.matrix_rank(U))
    u1,s1,w1 = np.linalg.svd(R1)     # need singular values for analysis
    u2,s2,w2 = np.linalg.svd(R2) 
    u3,s3,w3 = np.linalg.svd(R3)
    
    # calculate rank of each
    rank1 = s1[s1>1e-10].size
    rank2 = s2[s2>1e-10].size
    rank3 = s3[s3>1e-10].size
    Lr = [rank1,rank2,rank3]
    print('The rank of R1, R2, R3 are',Lr)
    print('Rank the R_is in smallest matrix rank ',np.argsort(Lr)+1)
    
    # calculate the total variance of each R_i
    var1 = np.sum(1/(80-1)*s1**2)
    var2 = np.sum(1/(80-1)*s2**2)
    var3 = np.sum(1/(80-1)*s3**2)
    Lv = [var1,var2,var3]
    print('The total variance of R1, R2, R3 are',Lv)
    print('Rank the R_is in largest explained variance ',np.flip(np.argsort(Lv))+1)
    
    # check if any calculation needed
    L = abs(np.array([np.mean(R1-R2),np.mean(R2-R3),np.mean(R1-R3)]))
    print('The differences between (R1,R2),(R2,R3),(R1,R3) are',L)
    
    # cost (modified Frobenius norm)
    index = np.where(U==-1000)
    U[index] = 0; R1[index] = 0; R2[index] = 0; R3[index] = 0
    c1 = np.sum((U-R1)**2)
    c2 = np.sum((U-R2)**2)
    c3 = np.sum((U-R3)**2)
    Lc = [c1,c2,c3]
    print('The cost of R1, R2, R3 are',Lc)
    print('Rank the R_is in smallest cost ',np.argsort(Lc)+1)
        
    return None #modify as needed

#----------------------
# Code for part 2
#----------------------
def model1d(a=0.028,b=0.053,L = 5,Nx=256,Nt=8001,T=4000,display=False,method='RK45',bc=0):
    """
    Question 2.1
    Simulate 2-species chemical reaction model

    Input:
    a,b: model parameters
    L: domain size
    Nx: Number of grid points in x
    Nt: Number of time steps
    T: Timespan for simulation is [0,T]
    Display: Function creates contour plot of f when true
    method: method used by solve_ivp
    bc:
        bc=0, homogeneous Neumann boundary conditions
        bc =/= 0, periodic boundary conditions

    Output:
    f,g: Nt x Nx arrays containing solution
    """

    #generate grid
    x = np.linspace(0,L,Nx)
    dx = x[1]-x[0]
    dx2inv = 1/dx**2

    #model constants
    d1 = 2e-5
    d2 = 1e-5

    def RHS(t,y):
        """
        RHS of model equations used by solve_ivp
        homogeneous Neumann boundary conditions
        """
        n = y.size//2
        f = y[:n]
        g = y[n:]

        #Compute 2nd derivatives
        d2f = (f[2:]-2*f[1:-1]+f[:-2])*dx2inv
        d2g = (g[2:]-2*g[1:-1]+g[:-2])*dx2inv

        #Construct RHS
        fg2 = f*g**2
        dfdt = d1*d2f - fg2[1:-1] - f[1:-1]*a + a
        dgdt = d2*d2g + fg2[1:-1] - (a+b)*g[1:-1]
        dy = np.zeros(2*n)
        dy[1:n-1] = dfdt
        dy[n+1:-1] = dgdt

        #Enforce boundary conditions
        a1,a2 = 4/3,-1/3
        dy[0] = a1*dy[1]+a2*dy[2]
        dy[n-1] = a1*dy[n-2]+a2*dy[n-3]
        dy[n] = a1*dy[n+1]+a2*dy[n+2]
        dy[-1] = a1*dy[-2]+a2*dy[-3]

        return dy

    def RHS2(t,y):
        """
        RHS of model equations used by solve_ivp,
        periodic boundary conditions
        """
        n = y.size//2
        f = y[:n]
        g = y[n:]

        #Compute 2nd derivatives
        d2f = np.zeros_like(f)
        d2g = np.zeros_like(g)
        d2f[1:-1] = (f[2:]-2*f[1:-1]+f[:-2])*dx2inv
        d2g[1:-1] = (g[2:]-2*g[1:-1]+g[:-2])*dx2inv

        d2f[0] = (f[1]-2*f[0]+f[-1])*dx2inv
        d2g[0] = (g[1]-2*g[0]+g[-1])*dx2inv
        d2f[-1] = d2f[0]
        d2g[-1] = d2g[0]

        fg2 = f*g**2
        dfdt = d1*d2f - fg2 - f*a + b
        dgdt = d2*d2g + fg2 - (a+b)*g
        dy = np.zeros(2*n)
        dy[:n] = dfdt
        dy[n:] = dgdt
        return dy

    #initial condition
    d = 1-4*(a+b)**2/a
    f0 = 0.5*(1+np.sqrt(d))
    g0 = 0.5*a/(a+b)*(1-np.sqrt(d))
    y0 = np.zeros(2*Nx)
    y0[:Nx] = f0 +0.1*np.cos(4*np.pi/L*x) + 1*np.cos(8*np.pi/L*x)
    y0[Nx:] = g0 +0.1*np.cos(2*np.pi/L*x) + 1*np.cos(6*np.pi/L*x)

    t = np.linspace(0,T,Nt)

    #compute solution
    print("running simulation...")
    if bc==0:
        out = solve_ivp(RHS,[t[0],t[-1]],y0,t_eval = t,rtol=1e-6,method=method)
    else:
        out = solve_ivp(RHS2,[t[0],t[-1]],y0,t_eval = t,rtol=1e-6,method=method)

    print(out.message)
    y =out.y
    f = y[:Nx,:]
    g = y[Nx:,:]
    print("finished simulation")
    if display:
        plt.figure()
        plt.contour(x,t,g.T)
        plt.xlabel('x')
        plt.ylabel('t')
        plt.title('Contours of f')

    return t,x,f,g

def part2q1analyze():
    """
    Question 2.1
    Add input/output as needed
    """
    # generate solution
    t,x,f,g = model1d()
    m = np.size(t)
    n = np.size(x)
    c,d = np.shape(f)   # g have same shape as f
    
    # extract some data to plot
    plt.figure(figsize=(15,6))
    plt.contour(x, t[250:], f[:,250:].T)    
    plt.xlabel('x')
    plt.ylabel('t')
    plt.colorbar()
    plt.title('Contours of f')

    # plot of 2d contour of g
    plt.figure(figsize=(15,6))
    plt.contour(x, t[250:], g[:,250:].T)   
    plt.xlabel('x')
    plt.ylabel('t')
    plt.colorbar()
    plt.title('Contours of g')
    
    # fourier of f, g along x
    r = d-1000   # ignore first 1000 values in t
    k = np.arange(-r/2,r/2)

    plt.figure(figsize=(10,7))  
    for i in range(50,256,50):
        ft = f[i,1000:]
        fc = np.fft.fft(ft)
        fc = np.fft.fftshift(fc)/r
        plt.semilogy(k,np.abs(fc))
        plt.title('Fourier coefficients of f along x')
        plt.xlabel('mode number, k')
        plt.ylabel('$|c_k|$')

    plt.figure(figsize=(10,7))  
    for i in range(50,256,50):
        gt = g[i,1000:] 
        gc = np.fft.fft(gt)
        gc = np.fft.fftshift(gc)/r
        plt.semilogy(k,np.abs(gc))
        plt.title('Fourier coefficients of g along x')
        plt.xlabel('mode number, k')
        plt.ylabel('$|c_k|$')

    # fourier of f, g along t
    q = c-50     # ignore first 50 values in x
    k = np.arange(-q/2,q/2)

    plt.figure(figsize=(10,7))  
    for i in range(1000,8001,1000):
        ft = f[50:,i]
        fc = np.fft.fft(ft)
        fc = np.fft.fftshift(fc)/q
        plt.semilogy(k,np.abs(fc))
        plt.title('Fourier coefficients of f along t')
        plt.xlabel('mode number, k')
        plt.ylabel('$|c_k|$')

    plt.figure(figsize=(10,7))  
    for i in range(1000,8001,1000):
        gt = g[50:,i] 
        gc = np.fft.fft(gt)
        gc = np.fft.fftshift(gc)/q
        plt.semilogy(k,np.abs(gc))
        plt.title('Fourier coefficients of g along t')
        plt.xlabel('mode number, k')
        plt.ylabel('$|c_k|$')
    
    # 3D plot
    fig1 = plt.figure(figsize=(10,10))
    ax1 = plt.axes(projection="3d")
    fig2 = plt.figure(figsize=(10,10))
    ax2 = plt.axes(projection="3d")
    for i in range(n):
        ax1.scatter(t, x[i]*np.ones(m), f[i, :], c=f[i,:], cmap='viridis')
        ax2.scatter(t, x[i]*np.ones(m), g[i, :], c=g[i,:], cmap='viridis')
    ax1.set_xlabel('Time')
    ax1.set_ylabel('Position')
    ax1.set_zlabel('Value of f')
    ax2.set_xlabel('Time')
    ax2.set_ylabel('Position')
    ax2.set_zlabel('Value of g')
    plt.show()

    return None #modify as needed


def part2q2(f,N,L,onlyX=False,onlyY=False):
    """
    Compute d2f/dx2 and d2f/dy2 of N x N array f on square equispaced grid
    with N points in each direction.
    f[i,j] corresponds to data at x[j] and y[i]

    Output:
    fxx: N x N numpy array; 2nd-derivative with respect to x computed using Fourier transforms
    assume underlying function is periodic in x, f(x+L)=f(x)

    fyy: N x N numpy array; 2nd-derivative with respect to y computed using implicit Finite
    difference scheme
    """

    #Generate grid (x,y are not explicitly needed here)
    x = np.linspace(0,L,N+1)
    x = x[:-1]
    y = x.copy()
    h = x[1]-x[0]
    h2inv = 1/h**2
    xg,yg = np.meshgrid(x,y)


    def diffx(f,L):
        """
        Question 2.1)
        Input:
            f: real array whose 2nd derivative will be computed along each row
            L: domain size
        Output:
            d2f: (real) second derivative of f computed with discrete Fourier transforms
        """
        d2f = np.zeros_like(f) #modify as needed

        #add code here
        # Compute the Fourier transform along the rows
        X = np.fft.fft(f, axis=1) / N
        n = np.arange(-N/2,N/2)
        n = np.fft.fftshift(n)
        k = 2 * np.pi * n / L
        d2f =  N * np.fft.ifft(-k**2*X).real
        
        return d2f #modify as needed

    def diffy(f,h2inv):
        """
        Question 2.2)
        Input:
            f: real array whose 2nd derivative will be computed along each column
            h2inv: 1/h^2 where h is the grid spacing
        Output:
            d2f: second derivative of f computed with implicit FD scheme
        """
        #coefficients for interior points
        alpha = 2/11
        a = 12/11
        b = 3/11

        #coefficients for near-boundary points
        alpha_bc = 10
        a_bc,b_bc,c_bc,d_bc,e_bc = (145/12,-76/3,29/2,-4/3,1/12)

        #add code here
        from scipy.linalg import solve_banded
        n = np.shape(f)[0]
        
        # A in Ax = b
        alpha_s = alpha * np.ones(n-2)
        A_b = np.vstack([np.hstack([0,alpha_s,0]), np.ones(n), np.hstack([-1,0,alpha_s])])
        
        # b 
        RHS = np.zeros_like(f)
        RHS[:,2:-2] = (b / 4 * (f[:,4:] - 2 * f[:,2:-2] + f[:,:-4]) + a * (f[:,3:-1] - 2 * f[:,2:-2] + f[:,1:-3])) * h2inv
        RHS[:,:2] = (a_bc * f[:,:2] + b_bc * f[:,1:3] + c_bc * f[:,2:4] + d_bc * f[:,3:5] + e_bc * f[:,4:6]) * h2inv
        RHS[:,-2:] =  (a_bc * f[:,-2:] + b_bc * f[:,-3:-1] + c_bc * f[:,-4:-2] + d_bc * f[:,-5:-3] + e_bc * f[:,-6:-4]) * h2inv

        # solve to compute the second derivative
        d2f = solve_banded((1, 1), A_b, RHS)

        return d2f #modify as needed

    # little modified to adapt to next question
    if onlyX:
        fxx = diffx(f,L)
        return x,fxx
    elif onlyY:
        fyy = diffy(f,h2inv)
        return y,fyy
    else:
        return x,y,fxx,fyy


def part2q2analyze():
    """
    Question 2.2(b)
    Add input/output as needed

    """
    # mean square error for testing accuracy
    def MSE(X,Y):
            return np.mean((X-Y)**2)

    # centered finite difference
    def CFDx(f,h):
        """function for centered finite difference
        use second order forward/backward finite differences at boundary
        """
        x = np.zeros_like(f)
        h2inv = 1/h**2   
        # use second order forward/backward finite differences at boundary
        x[1:-1, :] = (f[2:, :] - 2*f[1:-1, :] + f[:-2, :]) * h2inv
        x[0,:] = (f[0,:] - 2*f[1,:] + f[2,:]) * h2inv
        x[-1,:] = (f[-3,:] - 2*f[-2,:] + f[-1,:]) * h2inv

        return x

    def CFDy(f,h):
        """function for centered finite difference
        use second order forward/backward finite differences at boundary
        """
        y = np.zeros_like(f)
        h2inv = 1/h**2
        # use second order forward/backward finite differences at boundary
        y[:, 1:-1] = (f[:, 2:] - 2*f[:, 1:-1] + f[:, :-2]) * h2inv
        y[:,0] = (f[:,0] - 2*f[:,1] + f[:,2]) * h2inv
        y[:,-1] = (f[:,-3] - 2*f[:,-2] + f[:,-1]) * h2inv

        return y 

    def testfun(x,y):
        """generate a test function to support my analysis
        it is periodic with period = 2pi
        """
        return np.sin(x) * np.cos(y) + 0.5 * np.sin(2 * x) * np.sin(2 * y)

    def testderi(x,y):
        """true second order derivative of the test function
        by calculation, d2f/dx2, d2f/dy2 both have this formula
        """
        return -np.sin(x)*np.cos(y) - np.sin(2*x)*np.sin(2*y)*2

    # Some initialisation
    import time
    L = 80
    p = 30     # number of iterations
    Nvals = np.linspace(200,1000,9, dtype=int)    # ignore the trasient
    # accuracy: use MSE 
    MSE_dft, MSE_implicit, MSE_x2, MSE_y2 = [],[],[],[]
    # cost: measure running time
    time_dft, time_implicit, time_x2, time_y2 = [],[],[],[]
    
    # calculate MSE and measure the time for each methods
    for i in Nvals:
        h = L / (i-1)
        x,y = np.meshgrid(np.linspace(0, L, i+1)[:-1], np.linspace(0, L, i+1)[:-1])
        f = testfun(x,y)
        Dtrue = testderi(x,y)

        t1 = time.time()          # DFT
        for _ in range(p):
            _,fxx = part2q2(f,i,L,onlyX=True) 
        t2 = time.time()
        time_dft.append(t2-t1)

        t1 = time.time()          # implicit
        for _ in range(p):
            _,fyy = part2q2(f,i,L,onlyY=True)    
        t2 = time.time()
        time_implicit.append(t2-t1)

        t1 = time.time()          # CFD of x
        for _ in range(p):
            x2 = CFDx(f,h)   
        t2 = time.time()
        time_x2.append(t2-t1)

        t1 = time.time()          # CFD of y
        for _ in range(p):
            y2 = CFDy(f,h)
        t2 = time.time()
        time_y2.append(t2-t1)

        # store mse
        MSE_dft.append(MSE(fxx,Dtrue))
        MSE_implicit.append(MSE(fyy,Dtrue))
        MSE_x2.append(MSE(Dtrue,x2))
        MSE_y2.append(MSE(Dtrue,y2))

    # plotting of MSE
    fig, ax = plt.subplots(1, 2, figsize=(17, 7))

    ax[0].loglog(Nvals, MSE_dft, label='DFT')
    ax[0].loglog(Nvals, MSE_x2, label='Centered FD')
    ax[0].set_title(r'MSE of $d^2f/dx^2$')
    ax[0].set_xlabel('N')
    ax[0].set_ylabel('MSE')
    ax[0].legend()

    ax[1].loglog(Nvals, MSE_implicit, label='Implicit FD')
    ax[1].loglog(Nvals, MSE_y2, label='Centered FD')
    ax[1].set_title(r'MSE of $d^2f/dy^2$')
    ax[1].set_xlabel('N')
    ax[1].set_ylabel('MSE')
    ax[1].legend()
    
    # plots for running time
    fig, ax = plt.subplots(1, 2, figsize=(17, 7))

    ax[0].plot(Nvals, time_dft, label='DFT')
    ax[0].plot(Nvals, time_x2, label='Centered FD')
    ax[0].set_xlabel('N')
    ax[0].set_ylabel('Running Time')
    ax[0].legend()

    ax[1].plot(Nvals, time_implicit, label='Implicit FD')
    ax[1].plot(Nvals, time_y2, label='Centered FD')
    ax[1].set_xlabel('N')
    ax[1].set_ylabel('Running Time')
    ax[1].legend()
    
    # effectiveness
    # Wavenumber analysis
    h = 0.1
    k = np.linspace(0, np.pi/h, L)
    kh = k * h

    alpha = 2/11   # solving the constraint mentioned in report
    a = 12/11
    b = 3/11

    wn_im = (b * np.sin(kh)**2 - 2*a*(np.cos(kh)-1)) / (2*alpha*np.cos(kh)+1)
    
    plt.figure(figsize=(10,7))
    plt.plot(kh,kh**2,'--',label= r'$k^2h^2$',color='black')     
    plt.plot(kh,2-2*np.cos(kh),label='centered FD')   
    plt.plot(kh,wn_im,label='implicit FD')
    plt.legend()

    # DFT, compare fourier coefficients
    N = 300  
    h = L/N
    # dft
    x,y = np.meshgrid(np.linspace(0, L, 300+1)[:-1], np.linspace(0, L, 300+1)[:-1])
    f = testfun(x,y)
    _,fxx = part2q2(f,300,L,onlyX=True) 
    Dtrue = testderi(x,y)
    x2 = CFDx(f,h)
    
    N = np.shape(fxx)[0]
    c = np.fft.fft(fxx,axis=1)/N
    d = np.fft.fft(x2,axis=1)/N
    e = np.fft.fft(Dtrue,axis=1)/N
    n = np.arange(-N/2,N/2)

    j=280     # take one sample
    plt.figure(figsize=(12,7))
    plt.title('Compare Amplitude of Fourier coefficients (one sample)',fontsize=14)
    plt.plot(n[150:],np.fft.fftshift(np.abs(e[j,:]))[150:],linewidth=2.5, color='black')
    plt.plot(n[150:],np.fft.fftshift(np.abs(d[j,:]))[150:],'x--',color='orange')
    plt.plot(n[150:],np.fft.fftshift(np.abs(c[j,:]))[150:],'x--',color='violet')
    plt.legend(('True derivative','centered FD','DFT',))
    plt.xlabel('n')

    return None #modify as needed

#----------------------
if __name__=='__main__':
    pass
    #if you would like to call your functions, please call them from within
    #this if block
